# семинар 6 --- гетероскедастичность, квантильная регрессия, логит-модель

library(ggplot2) # графики
library(lmtest) # тестирование гипотез
library(sandwich) # se_HC
library(mfx) # логит-пробит
library(dplyr) # манипуляции с данными
library(hexbin) # графики с шестиугольничками
library(quantreg) # квантильная регрессия

# загружаем готовый набор данных из пакета ggplot2 
d <- diamonds
# структура данных
glimpse(d)
# справка по данным
help(diamonds)

# количество наблюдений (строк в таблице)
nrow(d)

# быстрый график: зависимость цены бриллианта от его массы
qplot(data=d, carat, price)

# для того чтобы построить более наглядный график,
# выберем случайно 1000 наблюдений и посмотрим на них
# зерно генератора случайных чисел для воспроизводимости эксперимента
set.seed(03)
# случайно выбираем 1000 чисел из набора чисел от 1 до количества строк таблицы
rows <- sample(1:nrow(d), size=1000)
head(rows)

# отбираем в новый набор данных строки из первоначальной таблицы
# со сгенерированными выше случайными номерами
d_sel <- d[rows, ]
# строим график для нового маленького набора
qplot(data=d_sel, carat, price)

# график с шестиугольничками, цветом показывает количество наблюдений
# в каждой области
qplot(data=d, carat, price, geom="hex")  

# добавим столбцы с логарифмами цен и логарифмами массы
d2 <- mutate(d, lprice=log(price), lcarat=log(carat))
# оценим линейную регрессию логарифма цены на логарифм массы и качество огранки
model <- lm(data=d2, lprice~lcarat + cut)

# график зависимости логарифма цены от логарифма массы
qplot(data=d2, x=lcarat, y=lprice, alpha=0.01)

# полученные коэффициенты и t-статистики
coeftest(model)
# t-статистики, рассчитанные с использованием
# устойчивых к гетероскедастичности стандартных ошибок
coeftest(model, vcov. = vcovHC)

# формальный тест на гетероскедастичность -- тест Бройша-Пагана
# нулевая гипотеза -- отсутствие гетероскедастичности
# для нашей модели отвергается, так как значение p-value очень маленькое
bptest(model)

# линейная регрессия цены на массу и качество огранки без логарифмов
model_0 <- lm(data=d2, price~carat + cut)
qplot(data=d, carat, price)

# квантильная регрессия для 10% самых дешевых бриллиантов, 
# половины и 10% самых дорогих
model_q <- rq(data=d2, price~carat+cut, tau = c(0.1,0.5,0.9))
# полученные коэффициенты и t-статистики
# для всех трех моделей
summary(model_q)

# логистическая регрессия
# создадим зависимую переменную, принимающую только два значения
# добавим переменную ideal, принимающую значение 1, если
# значение переменной cut(качество огранки) равно "Ideal" и 0 в остальных случаях 
d3 <- mutate(d2, ideal=ifelse(cut=="Ideal",1,0))
glimpse(d3)

# оценим логистическую регрессию 
# с только что созданной объясняемой переменной --- идеальность огранки 
# и объясняющими переменными: масса и чистота бриллианта
model_logit <- logitmfx(data=d3, ideal~ carat + clarity)

# полученные предельные эффекты показывают
# на сколько изменится вероятность y_i=1(вероятность того, что огранка идеальна) 
# при изменении значения объясняющей переменной на 1
model_logit

# полученные коэффициенты beta, показывают на какую величину
# изменится логарифм отношения вероятности того, что огранка будет идеальной
# к вероятности того, что она идеальной не будет (log(P(y_i=1)/P(y_i=0)))
# при изменении объясняющей переменной на 1
summary(model_logit$fit)

# например, при увеличении массы бриллианта на 1 карат
# шансы на то, что огранка будет идеальной, уменьшаются примерно на 50%
# (коэффициент -0.51)

# оценим сами предельный эффект и изменение шансов
# при увеличении массы бриллианта на 1 карат
# категории чистоты бриллиантов
levels(d3$clarity)

# так как предельные эффекты считаются в точке
# создадим сами набор данных с двумя наблюдениями и будем считать для них
# посмотрим на бриллианты с массой 15 и 16 карат и чистотой "IF" -- Internally Flawless
newdata <- data.frame(carat=c(15,16), clarity=c("IF","IF"))

# предскажем с помощью оцененной модели вероятность того, что
# огранка таких бриллиантов идеальна
# вероятность идельной огранки (предельный эффект) для бриллианта массой 15 карат 
# и чистотой "IF" при увеличении массы на 1 карат уменьшается на 0.05 процентных пункта,
# что составляет 40% от первоначальной величины 
predict(model_logit$fit, newdata=newdata, type="response")

# предскажем теперь логарифмы отношения 
# вероятности того, что огранка идеальна и того, что это не так (шансы)
# разница между ними составляет -0.51 и не зависит от выбранной точки
predict(model_logit$fit, newdata=newdata)

# пакет для смены кодировки в случае, 
# если case1 читался с кракозябрами вместо русских букв
# установить с github
devtools::install_github("bdemeshev/rims")
library(rims)

# эксперимент
a <- "Привет"
a
# искусственно изменили кодировку
library(stringr)
b <- str_conv(a,"cp1251")
b

# функция, чтобы всё наладить
str_utf2cp(b)


